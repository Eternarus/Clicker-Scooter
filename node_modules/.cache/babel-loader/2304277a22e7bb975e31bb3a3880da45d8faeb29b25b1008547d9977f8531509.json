{"ast":null,"code":"const path = require('path');\nconst Git = require('./git.js');\nconst async = require('async');\nconst fs = require('fs-extra');\n\n/**\n * Generate a list of unique directory paths given a list of file paths.\n * @param {Array<string>} files List of file paths.\n * @return {Array<string>} List of directory paths.\n */\nfunction uniqueDirs(files) {\n  const dirs = new Set();\n  files.forEach(filepath => {\n    const parts = path.dirname(filepath).split(path.sep);\n    let partial = parts[0] || '/';\n    dirs.add(partial);\n    for (let i = 1, ii = parts.length; i < ii; ++i) {\n      partial = path.join(partial, parts[i]);\n      dirs.add(partial);\n    }\n  });\n  return Array.from(dirs);\n}\nexports.uniqueDirs = uniqueDirs;\n\n/**\n * Sort function for paths.  Sorter paths come first.  Paths of equal length are\n * sorted alphanumerically in path segment order.\n * @param {string} a First path.\n * @param {string} b Second path.\n * @return {number} Comparison.\n */\nfunction byShortPath(a, b) {\n  const aParts = a.split(path.sep);\n  const bParts = b.split(path.sep);\n  const aLength = aParts.length;\n  const bLength = bParts.length;\n  let cmp = 0;\n  if (aLength < bLength) {\n    cmp = -1;\n  } else if (aLength > bLength) {\n    cmp = 1;\n  } else {\n    let aPart, bPart;\n    for (let i = 0; i < aLength; ++i) {\n      aPart = aParts[i];\n      bPart = bParts[i];\n      if (aPart < bPart) {\n        cmp = -1;\n        break;\n      } else if (aPart > bPart) {\n        cmp = 1;\n        break;\n      }\n    }\n  }\n  return cmp;\n}\nexports.byShortPath = byShortPath;\n\n/**\n * Generate a list of directories to create given a list of file paths.\n * @param {Array<string>} files List of file paths.\n * @return {Array<string>} List of directory paths ordered by path length.\n */\nfunction dirsToCreate(files) {\n  return uniqueDirs(files).sort(byShortPath);\n}\nexports.dirsToCreate = dirsToCreate;\n\n/**\n * Copy a file.\n * @param {object} obj Object with src and dest properties.\n * @param {function(Error)} callback Callback\n */\nfunction copyFile(obj, callback) {\n  let called = false;\n  function done(err) {\n    if (!called) {\n      called = true;\n      callback(err);\n    }\n  }\n  const read = fs.createReadStream(obj.src);\n  read.on('error', err => {\n    done(err);\n  });\n  const write = fs.createWriteStream(obj.dest);\n  write.on('error', err => {\n    done(err);\n  });\n  write.on('close', () => {\n    done();\n  });\n  read.pipe(write);\n}\nexports.copyFile = copyFile;\n\n/**\n * Make directory, ignoring errors if directory already exists.\n * @param {string} path Directory path.\n * @param {function(Error)} callback Callback.\n */\nfunction makeDir(path, callback) {\n  fs.mkdir(path, err => {\n    if (err) {\n      // check if directory exists\n      fs.stat(path, (err2, stat) => {\n        if (err2 || !stat.isDirectory()) {\n          callback(err);\n        } else {\n          callback();\n        }\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\n/**\n * Copy a list of files.\n * @param {Array<string>} files Files to copy.\n * @param {string} base Base directory.\n * @param {string} dest Destination directory.\n * @return {Promise} A promise.\n */\nexports.copy = function (files, base, dest) {\n  return new Promise((resolve, reject) => {\n    const pairs = [];\n    const destFiles = [];\n    files.forEach(file => {\n      const src = path.resolve(base, file);\n      const relative = path.relative(base, src);\n      const target = path.join(dest, relative);\n      pairs.push({\n        src: src,\n        dest: target\n      });\n      destFiles.push(target);\n    });\n    async.eachSeries(dirsToCreate(destFiles), makeDir, err => {\n      if (err) {\n        return reject(err);\n      }\n      async.each(pairs, copyFile, err => {\n        if (err) {\n          return reject(err);\n        } else {\n          return resolve();\n        }\n      });\n    });\n  });\n};\nexports.getUser = function (cwd) {\n  return Promise.all([new Git(cwd).exec('config', 'user.name'), new Git(cwd).exec('config', 'user.email')]).then(results => {\n    return {\n      name: results[0].output.trim(),\n      email: results[1].output.trim()\n    };\n  }).catch(err => {\n    // git config exits with 1 if name or email is not set\n    return null;\n  });\n};","map":{"version":3,"names":["path","require","Git","async","fs","uniqueDirs","files","dirs","Set","forEach","filepath","parts","dirname","split","sep","partial","add","i","ii","length","join","Array","from","exports","byShortPath","a","b","aParts","bParts","aLength","bLength","cmp","aPart","bPart","dirsToCreate","sort","copyFile","obj","callback","called","done","err","read","createReadStream","src","on","write","createWriteStream","dest","pipe","makeDir","mkdir","stat","err2","isDirectory","copy","base","Promise","resolve","reject","pairs","destFiles","file","relative","target","push","eachSeries","each","getUser","cwd","all","exec","then","results","name","output","trim","email","catch"],"sources":["C:/Users/mrdrd/OneDrive/Рабочий стол/Project/clicker/node_modules/gh-pages/lib/util.js"],"sourcesContent":["const path = require('path');\nconst Git = require('./git.js');\nconst async = require('async');\nconst fs = require('fs-extra');\n\n/**\n * Generate a list of unique directory paths given a list of file paths.\n * @param {Array<string>} files List of file paths.\n * @return {Array<string>} List of directory paths.\n */\nfunction uniqueDirs(files) {\n  const dirs = new Set();\n  files.forEach((filepath) => {\n    const parts = path.dirname(filepath).split(path.sep);\n    let partial = parts[0] || '/';\n    dirs.add(partial);\n    for (let i = 1, ii = parts.length; i < ii; ++i) {\n      partial = path.join(partial, parts[i]);\n      dirs.add(partial);\n    }\n  });\n  return Array.from(dirs);\n}\nexports.uniqueDirs = uniqueDirs;\n\n/**\n * Sort function for paths.  Sorter paths come first.  Paths of equal length are\n * sorted alphanumerically in path segment order.\n * @param {string} a First path.\n * @param {string} b Second path.\n * @return {number} Comparison.\n */\nfunction byShortPath(a, b) {\n  const aParts = a.split(path.sep);\n  const bParts = b.split(path.sep);\n  const aLength = aParts.length;\n  const bLength = bParts.length;\n  let cmp = 0;\n  if (aLength < bLength) {\n    cmp = -1;\n  } else if (aLength > bLength) {\n    cmp = 1;\n  } else {\n    let aPart, bPart;\n    for (let i = 0; i < aLength; ++i) {\n      aPart = aParts[i];\n      bPart = bParts[i];\n      if (aPart < bPart) {\n        cmp = -1;\n        break;\n      } else if (aPart > bPart) {\n        cmp = 1;\n        break;\n      }\n    }\n  }\n  return cmp;\n}\nexports.byShortPath = byShortPath;\n\n/**\n * Generate a list of directories to create given a list of file paths.\n * @param {Array<string>} files List of file paths.\n * @return {Array<string>} List of directory paths ordered by path length.\n */\nfunction dirsToCreate(files) {\n  return uniqueDirs(files).sort(byShortPath);\n}\nexports.dirsToCreate = dirsToCreate;\n\n/**\n * Copy a file.\n * @param {object} obj Object with src and dest properties.\n * @param {function(Error)} callback Callback\n */\nfunction copyFile(obj, callback) {\n  let called = false;\n  function done(err) {\n    if (!called) {\n      called = true;\n      callback(err);\n    }\n  }\n\n  const read = fs.createReadStream(obj.src);\n  read.on('error', (err) => {\n    done(err);\n  });\n\n  const write = fs.createWriteStream(obj.dest);\n  write.on('error', (err) => {\n    done(err);\n  });\n  write.on('close', () => {\n    done();\n  });\n\n  read.pipe(write);\n}\nexports.copyFile = copyFile;\n\n/**\n * Make directory, ignoring errors if directory already exists.\n * @param {string} path Directory path.\n * @param {function(Error)} callback Callback.\n */\nfunction makeDir(path, callback) {\n  fs.mkdir(path, (err) => {\n    if (err) {\n      // check if directory exists\n      fs.stat(path, (err2, stat) => {\n        if (err2 || !stat.isDirectory()) {\n          callback(err);\n        } else {\n          callback();\n        }\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\n/**\n * Copy a list of files.\n * @param {Array<string>} files Files to copy.\n * @param {string} base Base directory.\n * @param {string} dest Destination directory.\n * @return {Promise} A promise.\n */\nexports.copy = function (files, base, dest) {\n  return new Promise((resolve, reject) => {\n    const pairs = [];\n    const destFiles = [];\n    files.forEach((file) => {\n      const src = path.resolve(base, file);\n      const relative = path.relative(base, src);\n      const target = path.join(dest, relative);\n      pairs.push({\n        src: src,\n        dest: target,\n      });\n      destFiles.push(target);\n    });\n\n    async.eachSeries(dirsToCreate(destFiles), makeDir, (err) => {\n      if (err) {\n        return reject(err);\n      }\n      async.each(pairs, copyFile, (err) => {\n        if (err) {\n          return reject(err);\n        } else {\n          return resolve();\n        }\n      });\n    });\n  });\n};\n\nexports.getUser = function (cwd) {\n  return Promise.all([\n    new Git(cwd).exec('config', 'user.name'),\n    new Git(cwd).exec('config', 'user.email'),\n  ])\n    .then((results) => {\n      return {name: results[0].output.trim(), email: results[1].output.trim()};\n    })\n    .catch((err) => {\n      // git config exits with 1 if name or email is not set\n      return null;\n    });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}